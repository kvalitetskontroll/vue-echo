{"version":3,"sources":["webpack:///webpack/universalModuleDefinition","webpack:///build.js","webpack:///webpack/bootstrap 49f4c2c8fc9ec678880f","webpack:///./vue-echo.js","webpack:///./~/laravel-echo/dist/echo.common.js"],"names":["root","factory","exports","module","define","amd","this","modules","__webpack_require__","moduleId","installedModules","id","loaded","call","m","c","p","_interopRequireDefault","obj","__esModule","default","Object","defineProperty","value","_typeof","Symbol","iterator","constructor","prototype","_laravelEcho","_laravelEcho2","install","Vue","options","Error","socketId","$echo","Echo","mixin","mounted","_this","channel","$options","events","undefined","startsWith","private","replace","join","keys","forEach","key","listen","payload","$once","leave","classCallCheck","instance","Constructor","TypeError","createClass","defineProperties","target","props","i","length","descriptor","enumerable","configurable","writable","protoProps","staticProps","_extends","assign","arguments","source","hasOwnProperty","inherits","subClass","superClass","create","setPrototypeOf","__proto__","possibleConstructorReturn","self","ReferenceError","Connector","_defaultOptions","auth","headers","authEndpoint","broadcaster","csrfToken","host","namespace","setOptions","connect","selector","window","document","querySelector","getAttribute","Channel","event","callback","EventFormatter","setNamespace","charAt","substr","PusherChannel","_Channel","pusher","name","getPrototypeOf","eventFormatter","subscribe","subscription","unsubscribe","on","format","unbind","bind","PusherPrivateChannel","_PusherChannel","apply","eventName","data","channels","trigger","PusherPresenceChannel","members","map","k","member","info","SocketIoChannel","socket","configureReconnector","emit","removeListener","_this2","listener","_this3","push","_this4","SocketIoPrivateChannel","_SocketIoChannel","SocketIoPresenceChannel","_SocketIoPrivateChann","user_info","NullChannel","NullPrivateChannel","_NullChannel","NullPresenceChannel","PusherConnector","_Connector","client","Pusher","index","leaveChannel","connection","socket_id","disconnect","SocketIoConnector","io","getSocketIO","NullConnector","registerInterceptors","_channel","connector","presenceChannel","privateChannel","http","registerVueRequestInterceptor","axios","registerAxiosRequestInterceptor","jQuery","registerjQueryAjaxSetup","interceptors","request","next","set","use","config","ajax","ajaxSetup","beforeSend","xhr","setRequestHeader"],"mappings":"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","file":"build.js","sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"VueEcho\"] = factory();\n\telse\n\t\troot[\"VueEcho\"] = factory();\n})(this, function() {\nreturn \n\n\n// WEBPACK FOOTER //\n// webpack/universalModuleDefinition","(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"VueEcho\"] = factory();\n\telse\n\t\troot[\"VueEcho\"] = factory();\n})(this, function() {\nreturn /******/ (function(modules) { // webpackBootstrap\n/******/ \t// The module cache\n/******/ \tvar installedModules = {};\n/******/\n/******/ \t// The require function\n/******/ \tfunction __webpack_require__(moduleId) {\n/******/\n/******/ \t\t// Check if module is in cache\n/******/ \t\tif(installedModules[moduleId])\n/******/ \t\t\treturn installedModules[moduleId].exports;\n/******/\n/******/ \t\t// Create a new module (and put it into the cache)\n/******/ \t\tvar module = installedModules[moduleId] = {\n/******/ \t\t\texports: {},\n/******/ \t\t\tid: moduleId,\n/******/ \t\t\tloaded: false\n/******/ \t\t};\n/******/\n/******/ \t\t// Execute the module function\n/******/ \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n/******/\n/******/ \t\t// Flag the module as loaded\n/******/ \t\tmodule.loaded = true;\n/******/\n/******/ \t\t// Return the exports of the module\n/******/ \t\treturn module.exports;\n/******/ \t}\n/******/\n/******/\n/******/ \t// expose the modules object (__webpack_modules__)\n/******/ \t__webpack_require__.m = modules;\n/******/\n/******/ \t// expose the module cache\n/******/ \t__webpack_require__.c = installedModules;\n/******/\n/******/ \t// __webpack_public_path__\n/******/ \t__webpack_require__.p = \"\";\n/******/\n/******/ \t// Load entry module and return exports\n/******/ \treturn __webpack_require__(0);\n/******/ })\n/************************************************************************/\n/******/ ([\n/* 0 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\tmodule.exports = __webpack_require__(1);\n\n\n/***/ }),\n/* 1 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tObject.defineProperty(exports, \"__esModule\", {\n\t    value: true\n\t});\n\t\n\tvar _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; };\n\t\n\tvar _laravelEcho = __webpack_require__(2);\n\t\n\tvar _laravelEcho2 = _interopRequireDefault(_laravelEcho);\n\t\n\tfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\t\n\texports.default = {\n\t    install: function install(Vue, options) {\n\t        if (!options) {\n\t            throw new Error(\"[Vue-Echo] cannot locate options\");\n\t        }\n\t\n\t        if ((typeof options === 'undefined' ? 'undefined' : _typeof(options)) !== 'object') {\n\t            throw new Error(\"[Vue-Echo] cannot initiate options\");\n\t        }\n\t\n\t        if (typeof options.socketId == 'function') {\n\t            Vue.prototype.$echo = options;\n\t        } else {\n\t            Vue.prototype.$echo = new _laravelEcho2.default(options);\n\t        }\n\t\n\t        Vue.mixin({\n\t            mounted: function mounted() {\n\t                var _this = this;\n\t\n\t                var channel = this.$options['channel'];\n\t                var events = this.$options['echo'];\n\t\n\t                // Exit function if channel is undefined or null.\n\t                if (channel == undefined) {\n\t                    return;\n\t                }\n\t\n\t                // if channel is a function, evaluate the channel by running the provided callback function.\n\t                if (typeof channel === 'function') {\n\t                    channel = channel(this);\n\t                }\n\t\n\t                // After we evaluated potential callback, break if provided channel is not a string\n\t                if (typeof channel !== 'string') {\n\t                    throw new Error(\"[Vue-Echo] channel needs to be of type string\");\n\t                }\n\t\n\t                // Join correct channel\n\t                if (channel.startsWith('private:')) {\n\t                    this.channel = this.$echo.private(channel.replace('private:', ''));\n\t                } else if (channel.startsWith('presence:')) {\n\t                    this.channel = this.$echo.join(channel.replace('presence:', ''));\n\t                } else {\n\t                    this.channel = this.$echo.channel(channel);\n\t                }\n\t\n\t                // Add user-provided event listeners for the socket\n\t                if (events) {\n\t                    Object.keys(events).forEach(function (key) {\n\t                        // Bind the VM as second parameter\n\t                        _this.channel.listen(key, function (payload) {\n\t                            return events[key](payload, _this);\n\t                        });\n\t                    }, this);\n\t                }\n\t\n\t                /* Cleanup: Leave the channel on destroyed vue instance.\n\t                 * - Use an programmatic listener instead of the normal \"beforeDestroy\". This way, we do not have to do validation of the variable \"channel\" twice. \n\t                 */\n\t                this.$once('hook:beforeDestroy', function () {\n\t                    if (channel.startsWith('private:')) {\n\t                        channel = channel.replace('private:', '');\n\t                    } else if (channel.startsWith('presence:')) {\n\t                        channel = channel.replace('presence:', '');\n\t                    }\n\t\n\t                    _this.$echo.leave(channel);\n\t                });\n\t            }\n\t        });\n\t    }\n\t};\n\n/***/ }),\n/* 2 */\n/***/ (function(module, exports) {\n\n\t'use strict';\n\t\n\tvar classCallCheck = function (instance, Constructor) {\n\t  if (!(instance instanceof Constructor)) {\n\t    throw new TypeError(\"Cannot call a class as a function\");\n\t  }\n\t};\n\t\n\tvar createClass = function () {\n\t  function defineProperties(target, props) {\n\t    for (var i = 0; i < props.length; i++) {\n\t      var descriptor = props[i];\n\t      descriptor.enumerable = descriptor.enumerable || false;\n\t      descriptor.configurable = true;\n\t      if (\"value\" in descriptor) descriptor.writable = true;\n\t      Object.defineProperty(target, descriptor.key, descriptor);\n\t    }\n\t  }\n\t\n\t  return function (Constructor, protoProps, staticProps) {\n\t    if (protoProps) defineProperties(Constructor.prototype, protoProps);\n\t    if (staticProps) defineProperties(Constructor, staticProps);\n\t    return Constructor;\n\t  };\n\t}();\n\t\n\tvar _extends = Object.assign || function (target) {\n\t  for (var i = 1; i < arguments.length; i++) {\n\t    var source = arguments[i];\n\t\n\t    for (var key in source) {\n\t      if (Object.prototype.hasOwnProperty.call(source, key)) {\n\t        target[key] = source[key];\n\t      }\n\t    }\n\t  }\n\t\n\t  return target;\n\t};\n\t\n\tvar inherits = function (subClass, superClass) {\n\t  if (typeof superClass !== \"function\" && superClass !== null) {\n\t    throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass);\n\t  }\n\t\n\t  subClass.prototype = Object.create(superClass && superClass.prototype, {\n\t    constructor: {\n\t      value: subClass,\n\t      enumerable: false,\n\t      writable: true,\n\t      configurable: true\n\t    }\n\t  });\n\t  if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;\n\t};\n\t\n\tvar possibleConstructorReturn = function (self, call) {\n\t  if (!self) {\n\t    throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n\t  }\n\t\n\t  return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self;\n\t};\n\t\n\tvar Connector = function () {\n\t    /**\n\t     * Create a new class instance.\n\t     */\n\t    function Connector(options) {\n\t        classCallCheck(this, Connector);\n\t\n\t        /**\n\t         * Default connector options.\n\t         */\n\t        this._defaultOptions = {\n\t            auth: {\n\t                headers: {}\n\t            },\n\t            authEndpoint: '/broadcasting/auth',\n\t            broadcaster: 'pusher',\n\t            csrfToken: null,\n\t            host: null,\n\t            key: null,\n\t            namespace: 'App.Events'\n\t        };\n\t        this.setOptions(options);\n\t        this.connect();\n\t    }\n\t    /**\n\t     * Merge the custom options with the defaults.\n\t     */\n\t\n\t\n\t    createClass(Connector, [{\n\t        key: 'setOptions',\n\t        value: function setOptions(options) {\n\t            this.options = _extends(this._defaultOptions, options);\n\t            if (this.csrfToken()) {\n\t                this.options.auth.headers['X-CSRF-TOKEN'] = this.csrfToken();\n\t            }\n\t            return options;\n\t        }\n\t        /**\n\t         * Extract the CSRF token from the page.\n\t         */\n\t\n\t    }, {\n\t        key: 'csrfToken',\n\t        value: function csrfToken() {\n\t            var selector = void 0;\n\t            if (typeof window !== 'undefined' && window['Laravel'] && window['Laravel'].csrfToken) {\n\t                return window['Laravel'].csrfToken;\n\t            } else if (this.options.csrfToken) {\n\t                return this.options.csrfToken;\n\t            } else if (typeof document !== 'undefined' && (selector = document.querySelector('meta[name=\"csrf-token\"]'))) {\n\t                return selector.getAttribute('content');\n\t            }\n\t            return null;\n\t        }\n\t    }]);\n\t    return Connector;\n\t}();\n\t\n\t/**\n\t * This class represents a basic channel.\n\t */\n\tvar Channel = function () {\n\t  function Channel() {\n\t    classCallCheck(this, Channel);\n\t  }\n\t\n\t  createClass(Channel, [{\n\t    key: 'listenForWhisper',\n\t\n\t    /**\n\t     * Listen for a whisper event on the channel instance.\n\t     */\n\t    value: function listenForWhisper(event, callback) {\n\t      return this.listen('.client-' + event, callback);\n\t    }\n\t    /**\n\t     * Listen for an event on the channel instance.\n\t     */\n\t\n\t  }, {\n\t    key: 'notification',\n\t    value: function notification(callback) {\n\t      return this.listen('.Illuminate\\\\Notifications\\\\Events\\\\BroadcastNotificationCreated', callback);\n\t    }\n\t  }]);\n\t  return Channel;\n\t}();\n\t\n\t/**\n\t * Event name formatter\n\t */\n\tvar EventFormatter = function () {\n\t    /**\n\t     * Create a new class instance.\n\t     */\n\t    function EventFormatter(namespace) {\n\t        classCallCheck(this, EventFormatter);\n\t\n\t        this.setNamespace(namespace);\n\t    }\n\t    /**\n\t     * Format the given event name.\n\t     */\n\t\n\t\n\t    createClass(EventFormatter, [{\n\t        key: 'format',\n\t        value: function format(event) {\n\t            if (event.charAt(0) === '.' || event.charAt(0) === '\\\\') {\n\t                return event.substr(1);\n\t            } else if (this.namespace) {\n\t                event = this.namespace + '.' + event;\n\t            }\n\t            return event.replace(/\\./g, '\\\\');\n\t        }\n\t        /**\n\t         * Set the event namespace.\n\t         */\n\t\n\t    }, {\n\t        key: 'setNamespace',\n\t        value: function setNamespace(value) {\n\t            this.namespace = value;\n\t        }\n\t    }]);\n\t    return EventFormatter;\n\t}();\n\t\n\t/**\n\t * This class represents a Pusher channel.\n\t */\n\tvar PusherChannel = function (_Channel) {\n\t    inherits(PusherChannel, _Channel);\n\t\n\t    /**\n\t     * Create a new class instance.\n\t     */\n\t    function PusherChannel(pusher, name, options) {\n\t        classCallCheck(this, PusherChannel);\n\t\n\t        var _this = possibleConstructorReturn(this, (PusherChannel.__proto__ || Object.getPrototypeOf(PusherChannel)).call(this));\n\t\n\t        _this.name = name;\n\t        _this.pusher = pusher;\n\t        _this.options = options;\n\t        _this.eventFormatter = new EventFormatter(_this.options.namespace);\n\t        _this.subscribe();\n\t        return _this;\n\t    }\n\t    /**\n\t     * Subscribe to a Pusher channel.\n\t     */\n\t\n\t\n\t    createClass(PusherChannel, [{\n\t        key: 'subscribe',\n\t        value: function subscribe() {\n\t            this.subscription = this.pusher.subscribe(this.name);\n\t        }\n\t        /**\n\t         * Unsubscribe from a Pusher channel.\n\t         */\n\t\n\t    }, {\n\t        key: 'unsubscribe',\n\t        value: function unsubscribe() {\n\t            this.pusher.unsubscribe(this.name);\n\t        }\n\t        /**\n\t         * Listen for an event on the channel instance.\n\t         */\n\t\n\t    }, {\n\t        key: 'listen',\n\t        value: function listen(event, callback) {\n\t            this.on(this.eventFormatter.format(event), callback);\n\t            return this;\n\t        }\n\t        /**\n\t         * Stop listening for an event on the channel instance.\n\t         */\n\t\n\t    }, {\n\t        key: 'stopListening',\n\t        value: function stopListening(event) {\n\t            this.subscription.unbind(this.eventFormatter.format(event));\n\t            return this;\n\t        }\n\t        /**\n\t         * Bind a channel to an event.\n\t         */\n\t\n\t    }, {\n\t        key: 'on',\n\t        value: function on(event, callback) {\n\t            this.subscription.bind(event, callback);\n\t            return this;\n\t        }\n\t    }]);\n\t    return PusherChannel;\n\t}(Channel);\n\t\n\t/**\n\t * This class represents a Pusher private channel.\n\t */\n\tvar PusherPrivateChannel = function (_PusherChannel) {\n\t    inherits(PusherPrivateChannel, _PusherChannel);\n\t\n\t    function PusherPrivateChannel() {\n\t        classCallCheck(this, PusherPrivateChannel);\n\t        return possibleConstructorReturn(this, (PusherPrivateChannel.__proto__ || Object.getPrototypeOf(PusherPrivateChannel)).apply(this, arguments));\n\t    }\n\t\n\t    createClass(PusherPrivateChannel, [{\n\t        key: 'whisper',\n\t\n\t        /**\n\t         * Trigger client event on the channel.\n\t         */\n\t        value: function whisper(eventName, data) {\n\t            this.pusher.channels.channels[this.name].trigger('client-' + eventName, data);\n\t            return this;\n\t        }\n\t    }]);\n\t    return PusherPrivateChannel;\n\t}(PusherChannel);\n\t\n\t/**\n\t * This class represents a Pusher presence channel.\n\t */\n\tvar PusherPresenceChannel = function (_PusherChannel) {\n\t    inherits(PusherPresenceChannel, _PusherChannel);\n\t\n\t    function PusherPresenceChannel() {\n\t        classCallCheck(this, PusherPresenceChannel);\n\t        return possibleConstructorReturn(this, (PusherPresenceChannel.__proto__ || Object.getPrototypeOf(PusherPresenceChannel)).apply(this, arguments));\n\t    }\n\t\n\t    createClass(PusherPresenceChannel, [{\n\t        key: 'here',\n\t\n\t        /**\n\t         * Register a callback to be called anytime the member list changes.\n\t         */\n\t        value: function here(callback) {\n\t            this.on('pusher:subscription_succeeded', function (data) {\n\t                callback(Object.keys(data.members).map(function (k) {\n\t                    return data.members[k];\n\t                }));\n\t            });\n\t            return this;\n\t        }\n\t        /**\n\t         * Listen for someone joining the channel.\n\t         */\n\t\n\t    }, {\n\t        key: 'joining',\n\t        value: function joining(callback) {\n\t            this.on('pusher:member_added', function (member) {\n\t                callback(member.info);\n\t            });\n\t            return this;\n\t        }\n\t        /**\n\t         * Listen for someone leaving the channel.\n\t         */\n\t\n\t    }, {\n\t        key: 'leaving',\n\t        value: function leaving(callback) {\n\t            this.on('pusher:member_removed', function (member) {\n\t                callback(member.info);\n\t            });\n\t            return this;\n\t        }\n\t        /**\n\t         * Trigger client event on the channel.\n\t         */\n\t\n\t    }, {\n\t        key: 'whisper',\n\t        value: function whisper(eventName, data) {\n\t            this.pusher.channels.channels[this.name].trigger('client-' + eventName, data);\n\t            return this;\n\t        }\n\t    }]);\n\t    return PusherPresenceChannel;\n\t}(PusherChannel);\n\t\n\t/**\n\t * This class represents a Socket.io channel.\n\t */\n\tvar SocketIoChannel = function (_Channel) {\n\t    inherits(SocketIoChannel, _Channel);\n\t\n\t    /**\n\t     * Create a new class instance.\n\t     */\n\t    function SocketIoChannel(socket, name, options) {\n\t        classCallCheck(this, SocketIoChannel);\n\t\n\t        /**\n\t         * The event callbacks applied to the channel.\n\t         */\n\t        var _this = possibleConstructorReturn(this, (SocketIoChannel.__proto__ || Object.getPrototypeOf(SocketIoChannel)).call(this));\n\t\n\t        _this.events = {};\n\t        _this.name = name;\n\t        _this.socket = socket;\n\t        _this.options = options;\n\t        _this.eventFormatter = new EventFormatter(_this.options.namespace);\n\t        _this.subscribe();\n\t        _this.configureReconnector();\n\t        return _this;\n\t    }\n\t    /**\n\t     * Subscribe to a Socket.io channel.\n\t     */\n\t\n\t\n\t    createClass(SocketIoChannel, [{\n\t        key: 'subscribe',\n\t        value: function subscribe() {\n\t            this.socket.emit('subscribe', {\n\t                channel: this.name,\n\t                auth: this.options.auth || {}\n\t            });\n\t        }\n\t        /**\n\t         * Unsubscribe from channel and ubind event callbacks.\n\t         */\n\t\n\t    }, {\n\t        key: 'unsubscribe',\n\t        value: function unsubscribe() {\n\t            this.unbind();\n\t            this.socket.emit('unsubscribe', {\n\t                channel: this.name,\n\t                auth: this.options.auth || {}\n\t            });\n\t        }\n\t        /**\n\t         * Listen for an event on the channel instance.\n\t         */\n\t\n\t    }, {\n\t        key: 'listen',\n\t        value: function listen(event, callback) {\n\t            this.on(this.eventFormatter.format(event), callback);\n\t            return this;\n\t        }\n\t        /**\n\t         * Stop listening for an event on the channel instance.\n\t         */\n\t\n\t    }, {\n\t        key: 'stopListening',\n\t        value: function stopListening(event) {\n\t            var name = this.eventFormatter.format(event);\n\t            this.socket.removeListener(name);\n\t            delete this.events[name];\n\t            return this;\n\t        }\n\t        /**\n\t         * Bind the channel's socket to an event and store the callback.\n\t         */\n\t\n\t    }, {\n\t        key: 'on',\n\t        value: function on(event, callback) {\n\t            var _this2 = this;\n\t\n\t            var listener = function listener(channel, data) {\n\t                if (_this2.name == channel) {\n\t                    callback(data);\n\t                }\n\t            };\n\t            this.socket.on(event, listener);\n\t            this.bind(event, listener);\n\t        }\n\t        /**\n\t         * Attach a 'reconnect' listener and bind the event.\n\t         */\n\t\n\t    }, {\n\t        key: 'configureReconnector',\n\t        value: function configureReconnector() {\n\t            var _this3 = this;\n\t\n\t            var listener = function listener() {\n\t                _this3.subscribe();\n\t            };\n\t            this.socket.on('reconnect', listener);\n\t            this.bind('reconnect', listener);\n\t        }\n\t        /**\n\t         * Bind the channel's socket to an event and store the callback.\n\t         */\n\t\n\t    }, {\n\t        key: 'bind',\n\t        value: function bind(event, callback) {\n\t            this.events[event] = this.events[event] || [];\n\t            this.events[event].push(callback);\n\t        }\n\t        /**\n\t         * Unbind the channel's socket from all stored event callbacks.\n\t         */\n\t\n\t    }, {\n\t        key: 'unbind',\n\t        value: function unbind() {\n\t            var _this4 = this;\n\t\n\t            Object.keys(this.events).forEach(function (event) {\n\t                _this4.events[event].forEach(function (callback) {\n\t                    _this4.socket.removeListener(event, callback);\n\t                });\n\t                delete _this4.events[event];\n\t            });\n\t        }\n\t    }]);\n\t    return SocketIoChannel;\n\t}(Channel);\n\t\n\t/**\n\t * This class represents a Socket.io presence channel.\n\t */\n\tvar SocketIoPrivateChannel = function (_SocketIoChannel) {\n\t    inherits(SocketIoPrivateChannel, _SocketIoChannel);\n\t\n\t    function SocketIoPrivateChannel() {\n\t        classCallCheck(this, SocketIoPrivateChannel);\n\t        return possibleConstructorReturn(this, (SocketIoPrivateChannel.__proto__ || Object.getPrototypeOf(SocketIoPrivateChannel)).apply(this, arguments));\n\t    }\n\t\n\t    createClass(SocketIoPrivateChannel, [{\n\t        key: 'whisper',\n\t\n\t        /**\n\t         * Trigger client event on the channel.\n\t         */\n\t        value: function whisper(eventName, data) {\n\t            this.socket.emit('client event', {\n\t                channel: this.name,\n\t                event: 'client-' + eventName,\n\t                data: data\n\t            });\n\t            return this;\n\t        }\n\t    }]);\n\t    return SocketIoPrivateChannel;\n\t}(SocketIoChannel);\n\t\n\t/**\n\t * This class represents a Socket.io presence channel.\n\t */\n\tvar SocketIoPresenceChannel = function (_SocketIoPrivateChann) {\n\t    inherits(SocketIoPresenceChannel, _SocketIoPrivateChann);\n\t\n\t    function SocketIoPresenceChannel() {\n\t        classCallCheck(this, SocketIoPresenceChannel);\n\t        return possibleConstructorReturn(this, (SocketIoPresenceChannel.__proto__ || Object.getPrototypeOf(SocketIoPresenceChannel)).apply(this, arguments));\n\t    }\n\t\n\t    createClass(SocketIoPresenceChannel, [{\n\t        key: 'here',\n\t\n\t        /**\n\t         * Register a callback to be called anytime the member list changes.\n\t         */\n\t        value: function here(callback) {\n\t            this.on('presence:subscribed', function (members) {\n\t                callback(members.map(function (m) {\n\t                    return m.user_info;\n\t                }));\n\t            });\n\t            return this;\n\t        }\n\t        /**\n\t         * Listen for someone joining the channel.\n\t         */\n\t\n\t    }, {\n\t        key: 'joining',\n\t        value: function joining(callback) {\n\t            this.on('presence:joining', function (member) {\n\t                return callback(member.user_info);\n\t            });\n\t            return this;\n\t        }\n\t        /**\n\t         * Listen for someone leaving the channel.\n\t         */\n\t\n\t    }, {\n\t        key: 'leaving',\n\t        value: function leaving(callback) {\n\t            this.on('presence:leaving', function (member) {\n\t                return callback(member.user_info);\n\t            });\n\t            return this;\n\t        }\n\t    }]);\n\t    return SocketIoPresenceChannel;\n\t}(SocketIoPrivateChannel);\n\t\n\t/**\n\t * This class represents a null channel.\n\t */\n\tvar NullChannel = function (_Channel) {\n\t  inherits(NullChannel, _Channel);\n\t\n\t  function NullChannel() {\n\t    classCallCheck(this, NullChannel);\n\t    return possibleConstructorReturn(this, (NullChannel.__proto__ || Object.getPrototypeOf(NullChannel)).apply(this, arguments));\n\t  }\n\t\n\t  createClass(NullChannel, [{\n\t    key: 'subscribe',\n\t\n\t    /**\n\t     * Subscribe to a channel.\n\t     */\n\t    value: function subscribe() {}\n\t    //\n\t\n\t    /**\n\t     * Unsubscribe from a channel.\n\t     */\n\t\n\t  }, {\n\t    key: 'unsubscribe',\n\t    value: function unsubscribe() {}\n\t    //\n\t\n\t    /**\n\t     * Listen for an event on the channel instance.\n\t     */\n\t\n\t  }, {\n\t    key: 'listen',\n\t    value: function listen(event, callback) {\n\t      return this;\n\t    }\n\t    /**\n\t     * Stop listening for an event on the channel instance.\n\t     */\n\t\n\t  }, {\n\t    key: 'stopListening',\n\t    value: function stopListening(event) {\n\t      return this;\n\t    }\n\t    /**\n\t     * Bind a channel to an event.\n\t     */\n\t\n\t  }, {\n\t    key: 'on',\n\t    value: function on(event, callback) {\n\t      return this;\n\t    }\n\t  }]);\n\t  return NullChannel;\n\t}(Channel);\n\t\n\t/**\n\t * This class represents a null private channel.\n\t */\n\tvar NullPrivateChannel = function (_NullChannel) {\n\t  inherits(NullPrivateChannel, _NullChannel);\n\t\n\t  function NullPrivateChannel() {\n\t    classCallCheck(this, NullPrivateChannel);\n\t    return possibleConstructorReturn(this, (NullPrivateChannel.__proto__ || Object.getPrototypeOf(NullPrivateChannel)).apply(this, arguments));\n\t  }\n\t\n\t  createClass(NullPrivateChannel, [{\n\t    key: 'whisper',\n\t\n\t    /**\n\t     * Trigger client event on the channel.\n\t     */\n\t    value: function whisper(eventName, data) {\n\t      return this;\n\t    }\n\t  }]);\n\t  return NullPrivateChannel;\n\t}(NullChannel);\n\t\n\t/**\n\t * This class represents a null presence channel.\n\t */\n\tvar NullPresenceChannel = function (_NullChannel) {\n\t  inherits(NullPresenceChannel, _NullChannel);\n\t\n\t  function NullPresenceChannel() {\n\t    classCallCheck(this, NullPresenceChannel);\n\t    return possibleConstructorReturn(this, (NullPresenceChannel.__proto__ || Object.getPrototypeOf(NullPresenceChannel)).apply(this, arguments));\n\t  }\n\t\n\t  createClass(NullPresenceChannel, [{\n\t    key: 'here',\n\t\n\t    /**\n\t     * Register a callback to be called anytime the member list changes.\n\t     */\n\t    value: function here(callback) {\n\t      return this;\n\t    }\n\t    /**\n\t     * Listen for someone joining the channel.\n\t     */\n\t\n\t  }, {\n\t    key: 'joining',\n\t    value: function joining(callback) {\n\t      return this;\n\t    }\n\t    /**\n\t     * Listen for someone leaving the channel.\n\t     */\n\t\n\t  }, {\n\t    key: 'leaving',\n\t    value: function leaving(callback) {\n\t      return this;\n\t    }\n\t    /**\n\t     * Trigger client event on the channel.\n\t     */\n\t\n\t  }, {\n\t    key: 'whisper',\n\t    value: function whisper(eventName, data) {\n\t      return this;\n\t    }\n\t  }]);\n\t  return NullPresenceChannel;\n\t}(NullChannel);\n\t\n\t/**\n\t * This class creates a connector to Pusher.\n\t */\n\tvar PusherConnector = function (_Connector) {\n\t    inherits(PusherConnector, _Connector);\n\t\n\t    function PusherConnector() {\n\t        classCallCheck(this, PusherConnector);\n\t\n\t        /**\n\t         * All of the subscribed channel names.\n\t         */\n\t        var _this = possibleConstructorReturn(this, (PusherConnector.__proto__ || Object.getPrototypeOf(PusherConnector)).apply(this, arguments));\n\t\n\t        _this.channels = {};\n\t        return _this;\n\t    }\n\t    /**\n\t     * Create a fresh Pusher connection.\n\t     */\n\t\n\t\n\t    createClass(PusherConnector, [{\n\t        key: 'connect',\n\t        value: function connect() {\n\t            if (typeof this.options.client !== 'undefined') {\n\t                this.pusher = this.options.client;\n\t            } else {\n\t                this.pusher = new Pusher(this.options.key, this.options);\n\t            }\n\t        }\n\t        /**\n\t         * Listen for an event on a channel instance.\n\t         */\n\t\n\t    }, {\n\t        key: 'listen',\n\t        value: function listen(name, event, callback) {\n\t            return this.channel(name).listen(event, callback);\n\t        }\n\t        /**\n\t         * Get a channel instance by name.\n\t         */\n\t\n\t    }, {\n\t        key: 'channel',\n\t        value: function channel(name) {\n\t            if (!this.channels[name]) {\n\t                this.channels[name] = new PusherChannel(this.pusher, name, this.options);\n\t            }\n\t            return this.channels[name];\n\t        }\n\t        /**\n\t         * Get a private channel instance by name.\n\t         */\n\t\n\t    }, {\n\t        key: 'privateChannel',\n\t        value: function privateChannel(name) {\n\t            if (!this.channels['private-' + name]) {\n\t                this.channels['private-' + name] = new PusherPrivateChannel(this.pusher, 'private-' + name, this.options);\n\t            }\n\t            return this.channels['private-' + name];\n\t        }\n\t        /**\n\t         * Get a presence channel instance by name.\n\t         */\n\t\n\t    }, {\n\t        key: 'presenceChannel',\n\t        value: function presenceChannel(name) {\n\t            if (!this.channels['presence-' + name]) {\n\t                this.channels['presence-' + name] = new PusherPresenceChannel(this.pusher, 'presence-' + name, this.options);\n\t            }\n\t            return this.channels['presence-' + name];\n\t        }\n\t        /**\n\t         * Leave the given channel, as well as its private and presence variants.\n\t         */\n\t\n\t    }, {\n\t        key: 'leave',\n\t        value: function leave(name) {\n\t            var _this2 = this;\n\t\n\t            var channels = [name, 'private-' + name, 'presence-' + name];\n\t            channels.forEach(function (name, index) {\n\t                _this2.leaveChannel(name);\n\t            });\n\t        }\n\t        /**\n\t         * Leave the given channel.\n\t         */\n\t\n\t    }, {\n\t        key: 'leaveChannel',\n\t        value: function leaveChannel(name) {\n\t            if (this.channels[name]) {\n\t                this.channels[name].unsubscribe();\n\t                delete this.channels[name];\n\t            }\n\t        }\n\t        /**\n\t         * Get the socket ID for the connection.\n\t         */\n\t\n\t    }, {\n\t        key: 'socketId',\n\t        value: function socketId() {\n\t            return this.pusher.connection.socket_id;\n\t        }\n\t        /**\n\t         * Disconnect Pusher connection.\n\t         */\n\t\n\t    }, {\n\t        key: 'disconnect',\n\t        value: function disconnect() {\n\t            this.pusher.disconnect();\n\t        }\n\t    }]);\n\t    return PusherConnector;\n\t}(Connector);\n\t\n\t/**\n\t * This class creates a connnector to a Socket.io server.\n\t */\n\tvar SocketIoConnector = function (_Connector) {\n\t    inherits(SocketIoConnector, _Connector);\n\t\n\t    function SocketIoConnector() {\n\t        classCallCheck(this, SocketIoConnector);\n\t\n\t        /**\n\t         * All of the subscribed channel names.\n\t         */\n\t        var _this = possibleConstructorReturn(this, (SocketIoConnector.__proto__ || Object.getPrototypeOf(SocketIoConnector)).apply(this, arguments));\n\t\n\t        _this.channels = {};\n\t        return _this;\n\t    }\n\t    /**\n\t     * Create a fresh Socket.io connection.\n\t     */\n\t\n\t\n\t    createClass(SocketIoConnector, [{\n\t        key: 'connect',\n\t        value: function connect() {\n\t            var io = this.getSocketIO();\n\t            this.socket = io(this.options.host, this.options);\n\t            return this.socket;\n\t        }\n\t        /**\n\t         * Get socket.io module from global scope or options.\n\t         */\n\t\n\t    }, {\n\t        key: 'getSocketIO',\n\t        value: function getSocketIO() {\n\t            if (typeof io !== 'undefined') {\n\t                return io;\n\t            }\n\t            if (typeof this.options.client !== 'undefined') {\n\t                return this.options.client;\n\t            }\n\t            throw new Error('Socket.io client not found. Should be globally available or passed via options.client');\n\t        }\n\t        /**\n\t         * Listen for an event on a channel instance.\n\t         */\n\t\n\t    }, {\n\t        key: 'listen',\n\t        value: function listen(name, event, callback) {\n\t            return this.channel(name).listen(event, callback);\n\t        }\n\t        /**\n\t         * Get a channel instance by name.\n\t         */\n\t\n\t    }, {\n\t        key: 'channel',\n\t        value: function channel(name) {\n\t            if (!this.channels[name]) {\n\t                this.channels[name] = new SocketIoChannel(this.socket, name, this.options);\n\t            }\n\t            return this.channels[name];\n\t        }\n\t        /**\n\t         * Get a private channel instance by name.\n\t         */\n\t\n\t    }, {\n\t        key: 'privateChannel',\n\t        value: function privateChannel(name) {\n\t            if (!this.channels['private-' + name]) {\n\t                this.channels['private-' + name] = new SocketIoPrivateChannel(this.socket, 'private-' + name, this.options);\n\t            }\n\t            return this.channels['private-' + name];\n\t        }\n\t        /**\n\t         * Get a presence channel instance by name.\n\t         */\n\t\n\t    }, {\n\t        key: 'presenceChannel',\n\t        value: function presenceChannel(name) {\n\t            if (!this.channels['presence-' + name]) {\n\t                this.channels['presence-' + name] = new SocketIoPresenceChannel(this.socket, 'presence-' + name, this.options);\n\t            }\n\t            return this.channels['presence-' + name];\n\t        }\n\t        /**\n\t         * Leave the given channel, as well as its private and presence variants.\n\t         */\n\t\n\t    }, {\n\t        key: 'leave',\n\t        value: function leave(name) {\n\t            var _this2 = this;\n\t\n\t            var channels = [name, 'private-' + name, 'presence-' + name];\n\t            channels.forEach(function (name) {\n\t                _this2.leaveChannel(name);\n\t            });\n\t        }\n\t        /**\n\t         * Leave the given channel.\n\t         */\n\t\n\t    }, {\n\t        key: 'leaveChannel',\n\t        value: function leaveChannel(name) {\n\t            if (this.channels[name]) {\n\t                this.channels[name].unsubscribe();\n\t                delete this.channels[name];\n\t            }\n\t        }\n\t        /**\n\t         * Get the socket ID for the connection.\n\t         */\n\t\n\t    }, {\n\t        key: 'socketId',\n\t        value: function socketId() {\n\t            return this.socket.id;\n\t        }\n\t        /**\n\t         * Disconnect Socketio connection.\n\t         */\n\t\n\t    }, {\n\t        key: 'disconnect',\n\t        value: function disconnect() {\n\t            this.socket.disconnect();\n\t        }\n\t    }]);\n\t    return SocketIoConnector;\n\t}(Connector);\n\t\n\t/**\n\t * This class creates a null connector.\n\t */\n\tvar NullConnector = function (_Connector) {\n\t  inherits(NullConnector, _Connector);\n\t\n\t  function NullConnector() {\n\t    classCallCheck(this, NullConnector);\n\t\n\t    /**\n\t     * All of the subscribed channel names.\n\t     */\n\t    var _this = possibleConstructorReturn(this, (NullConnector.__proto__ || Object.getPrototypeOf(NullConnector)).apply(this, arguments));\n\t\n\t    _this.channels = {};\n\t    return _this;\n\t  }\n\t  /**\n\t   * Create a fresh connection.\n\t   */\n\t\n\t\n\t  createClass(NullConnector, [{\n\t    key: 'connect',\n\t    value: function connect() {}\n\t    //\n\t\n\t    /**\n\t     * Listen for an event on a channel instance.\n\t     */\n\t\n\t  }, {\n\t    key: 'listen',\n\t    value: function listen(name, event, callback) {\n\t      return new NullChannel();\n\t    }\n\t    /**\n\t     * Get a channel instance by name.\n\t     */\n\t\n\t  }, {\n\t    key: 'channel',\n\t    value: function channel(name) {\n\t      return new NullChannel();\n\t    }\n\t    /**\n\t     * Get a private channel instance by name.\n\t     */\n\t\n\t  }, {\n\t    key: 'privateChannel',\n\t    value: function privateChannel(name) {\n\t      return new NullPrivateChannel();\n\t    }\n\t    /**\n\t     * Get a presence channel instance by name.\n\t     */\n\t\n\t  }, {\n\t    key: 'presenceChannel',\n\t    value: function presenceChannel(name) {\n\t      return new NullPresenceChannel();\n\t    }\n\t    /**\n\t     * Leave the given channel, as well as its private and presence variants.\n\t     */\n\t\n\t  }, {\n\t    key: 'leave',\n\t    value: function leave(name) {}\n\t    //\n\t\n\t    /**\n\t     * Leave the given channel.\n\t     */\n\t\n\t  }, {\n\t    key: 'leaveChannel',\n\t    value: function leaveChannel(name) {}\n\t    //\n\t\n\t    /**\n\t     * Get the socket ID for the connection.\n\t     */\n\t\n\t  }, {\n\t    key: 'socketId',\n\t    value: function socketId() {\n\t      return 'fake-socket-id';\n\t    }\n\t    /**\n\t     * Disconnect the connection.\n\t     */\n\t\n\t  }, {\n\t    key: 'disconnect',\n\t    value: function disconnect() {\n\t      //\n\t    }\n\t  }]);\n\t  return NullConnector;\n\t}(Connector);\n\t\n\t/**\n\t * This class is the primary API for interacting with broadcasting.\n\t */\n\t\n\tvar Echo = function () {\n\t    /**\n\t     * Create a new class instance.\n\t     */\n\t    function Echo(options) {\n\t        classCallCheck(this, Echo);\n\t\n\t        this.options = options;\n\t        this.connect();\n\t        this.registerInterceptors();\n\t    }\n\t    /**\n\t     * Get a channel instance by name.\n\t     */\n\t\n\t\n\t    createClass(Echo, [{\n\t        key: 'channel',\n\t        value: function channel(_channel) {\n\t            return this.connector.channel(_channel);\n\t        }\n\t        /**\n\t         * Create a new connection.\n\t         */\n\t\n\t    }, {\n\t        key: 'connect',\n\t        value: function connect() {\n\t            if (this.options.broadcaster == 'pusher') {\n\t                this.connector = new PusherConnector(this.options);\n\t            } else if (this.options.broadcaster == 'socket.io') {\n\t                this.connector = new SocketIoConnector(this.options);\n\t            } else if (this.options.broadcaster == 'null') {\n\t                this.connector = new NullConnector(this.options);\n\t            }\n\t        }\n\t        /**\n\t         * Disconnect from the Echo server.\n\t         */\n\t\n\t    }, {\n\t        key: 'disconnect',\n\t        value: function disconnect() {\n\t            this.connector.disconnect();\n\t        }\n\t        /**\n\t         * Get a presence channel instance by name.\n\t         */\n\t\n\t    }, {\n\t        key: 'join',\n\t        value: function join(channel) {\n\t            return this.connector.presenceChannel(channel);\n\t        }\n\t        /**\n\t         * Leave the given channel, as well as its private and presence variants.\n\t         */\n\t\n\t    }, {\n\t        key: 'leave',\n\t        value: function leave(channel) {\n\t            this.connector.leave(channel);\n\t        }\n\t        /**\n\t         * Leave the given channel.\n\t         */\n\t\n\t    }, {\n\t        key: 'leaveChannel',\n\t        value: function leaveChannel(channel) {\n\t            this.connector.leaveChannel(channel);\n\t        }\n\t        /**\n\t         * Listen for an event on a channel instance.\n\t         */\n\t\n\t    }, {\n\t        key: 'listen',\n\t        value: function listen(channel, event, callback) {\n\t            return this.connector.listen(channel, event, callback);\n\t        }\n\t        /**\n\t         * Get a private channel instance by name.\n\t         */\n\t\n\t    }, {\n\t        key: 'private',\n\t        value: function _private(channel) {\n\t            return this.connector.privateChannel(channel);\n\t        }\n\t        /**\n\t         * Get the Socket ID for the connection.\n\t         */\n\t\n\t    }, {\n\t        key: 'socketId',\n\t        value: function socketId() {\n\t            return this.connector.socketId();\n\t        }\n\t        /**\n\t         * Register 3rd party request interceptiors. These are used to automatically\n\t         * send a connections socket id to a Laravel app with a X-Socket-Id header.\n\t         */\n\t\n\t    }, {\n\t        key: 'registerInterceptors',\n\t        value: function registerInterceptors() {\n\t            if (typeof Vue === 'function' && Vue.http) {\n\t                this.registerVueRequestInterceptor();\n\t            }\n\t            if (typeof axios === 'function') {\n\t                this.registerAxiosRequestInterceptor();\n\t            }\n\t            if (typeof jQuery === 'function') {\n\t                this.registerjQueryAjaxSetup();\n\t            }\n\t        }\n\t        /**\n\t         * Register a Vue HTTP interceptor to add the X-Socket-ID header.\n\t         */\n\t\n\t    }, {\n\t        key: 'registerVueRequestInterceptor',\n\t        value: function registerVueRequestInterceptor() {\n\t            var _this = this;\n\t\n\t            Vue.http.interceptors.push(function (request, next) {\n\t                if (_this.socketId()) {\n\t                    request.headers.set('X-Socket-ID', _this.socketId());\n\t                }\n\t                next();\n\t            });\n\t        }\n\t        /**\n\t         * Register an Axios HTTP interceptor to add the X-Socket-ID header.\n\t         */\n\t\n\t    }, {\n\t        key: 'registerAxiosRequestInterceptor',\n\t        value: function registerAxiosRequestInterceptor() {\n\t            var _this2 = this;\n\t\n\t            axios.interceptors.request.use(function (config) {\n\t                if (_this2.socketId()) {\n\t                    config.headers['X-Socket-Id'] = _this2.socketId();\n\t                }\n\t                return config;\n\t            });\n\t        }\n\t        /**\n\t         * Register jQuery AjaxSetup to add the X-Socket-ID header.\n\t         */\n\t\n\t    }, {\n\t        key: 'registerjQueryAjaxSetup',\n\t        value: function registerjQueryAjaxSetup() {\n\t            var _this3 = this;\n\t\n\t            if (typeof jQuery.ajax != 'undefined') {\n\t                jQuery.ajaxSetup({\n\t                    beforeSend: function beforeSend(xhr) {\n\t                        if (_this3.socketId()) {\n\t                            xhr.setRequestHeader('X-Socket-Id', _this3.socketId());\n\t                        }\n\t                    }\n\t                });\n\t            }\n\t        }\n\t    }]);\n\t    return Echo;\n\t}();\n\t\n\tmodule.exports = Echo;\n\n\n/***/ })\n/******/ ])\n});\n;\n\n\n// WEBPACK FOOTER //\n// build.js"," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId])\n \t\t\treturn installedModules[moduleId].exports;\n\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\texports: {},\n \t\t\tid: moduleId,\n \t\t\tloaded: false\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.loaded = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(0);\n\n\n\n// WEBPACK FOOTER //\n// webpack/bootstrap 49f4c2c8fc9ec678880f","import Echo from 'laravel-echo';\n\nexport default {\n    install(Vue, options) {\n        if (!options) {\n            throw new Error(\"[Vue-Echo] cannot locate options\");\n        }\n\n        if (typeof options !== 'object') {\n            throw new Error(\"[Vue-Echo] cannot initiate options\");\n        }\n\n        if(typeof options.socketId == 'function')\n        {\n            Vue.prototype.$echo = options;\n        }\n        else\n        {\n            Vue.prototype.$echo = new Echo(options);\n        }\n\n        Vue.mixin({\n            mounted() {\n                let channel = this.$options['channel'];\n                const events = this.$options['echo'];\n\n                // Exit function if channel is undefined or null.\n                if(channel == undefined)\n                {\n                    return\n                } \n                \n                // if channel is a function, evaluate the channel by running the provided callback function.\n                if(typeof channel === 'function')\n                {\n                    channel = channel(this)\n                }\n                \n                // After we evaluated potential callback, break if provided channel is not a string\n                if(typeof channel !== 'string')\n                {\n                    throw new Error(\"[Vue-Echo] channel needs to be of type string\");\n                }\n                \n                // Join correct channel\n                if(channel.startsWith('private:'))\n                {\n                    this.channel = this.$echo.private(channel.replace('private:', ''))\n                }\n                else if(channel.startsWith('presence:'))\n                {\n                    this.channel = this.$echo.join(channel.replace('presence:', ''))\n                }\n                else\n                {\n                    this.channel = this.$echo.channel(channel);\n                }\n\n                \n                // Add user-provided event listeners for the socket\n                if(events)\n                {\n                    Object.keys(events).forEach(key => {\n                        // Bind the VM as second parameter\n                        this.channel.listen(key, (payload) => events[key](payload, this));\n                    }, this);\n                }\n\n                /* Cleanup: Leave the channel on destroyed vue instance.\n                 * - Use an programmatic listener instead of the normal \"beforeDestroy\". This way, we do not have to do validation of the variable \"channel\" twice. \n                 */\n                this.$once('hook:beforeDestroy', () => {\n                    if(channel.startsWith('private:'))\n                    {\n                        channel = channel.replace('private:', '');\n                    }\n                    else if(channel.startsWith('presence:'))\n                    {\n                        channel = channel.replace('presence:', '');\n                    }\n\n                    this.$echo.leave(channel);\n                })\n            }\n        })\n    }\n}\n\n\n// WEBPACK FOOTER //\n// ./vue-echo.js","'use strict';\n\nvar classCallCheck = function (instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n};\n\nvar createClass = function () {\n  function defineProperties(target, props) {\n    for (var i = 0; i < props.length; i++) {\n      var descriptor = props[i];\n      descriptor.enumerable = descriptor.enumerable || false;\n      descriptor.configurable = true;\n      if (\"value\" in descriptor) descriptor.writable = true;\n      Object.defineProperty(target, descriptor.key, descriptor);\n    }\n  }\n\n  return function (Constructor, protoProps, staticProps) {\n    if (protoProps) defineProperties(Constructor.prototype, protoProps);\n    if (staticProps) defineProperties(Constructor, staticProps);\n    return Constructor;\n  };\n}();\n\nvar _extends = Object.assign || function (target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = arguments[i];\n\n    for (var key in source) {\n      if (Object.prototype.hasOwnProperty.call(source, key)) {\n        target[key] = source[key];\n      }\n    }\n  }\n\n  return target;\n};\n\nvar inherits = function (subClass, superClass) {\n  if (typeof superClass !== \"function\" && superClass !== null) {\n    throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass);\n  }\n\n  subClass.prototype = Object.create(superClass && superClass.prototype, {\n    constructor: {\n      value: subClass,\n      enumerable: false,\n      writable: true,\n      configurable: true\n    }\n  });\n  if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;\n};\n\nvar possibleConstructorReturn = function (self, call) {\n  if (!self) {\n    throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n  }\n\n  return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self;\n};\n\nvar Connector = function () {\n    /**\n     * Create a new class instance.\n     */\n    function Connector(options) {\n        classCallCheck(this, Connector);\n\n        /**\n         * Default connector options.\n         */\n        this._defaultOptions = {\n            auth: {\n                headers: {}\n            },\n            authEndpoint: '/broadcasting/auth',\n            broadcaster: 'pusher',\n            csrfToken: null,\n            host: null,\n            key: null,\n            namespace: 'App.Events'\n        };\n        this.setOptions(options);\n        this.connect();\n    }\n    /**\n     * Merge the custom options with the defaults.\n     */\n\n\n    createClass(Connector, [{\n        key: 'setOptions',\n        value: function setOptions(options) {\n            this.options = _extends(this._defaultOptions, options);\n            if (this.csrfToken()) {\n                this.options.auth.headers['X-CSRF-TOKEN'] = this.csrfToken();\n            }\n            return options;\n        }\n        /**\n         * Extract the CSRF token from the page.\n         */\n\n    }, {\n        key: 'csrfToken',\n        value: function csrfToken() {\n            var selector = void 0;\n            if (typeof window !== 'undefined' && window['Laravel'] && window['Laravel'].csrfToken) {\n                return window['Laravel'].csrfToken;\n            } else if (this.options.csrfToken) {\n                return this.options.csrfToken;\n            } else if (typeof document !== 'undefined' && (selector = document.querySelector('meta[name=\"csrf-token\"]'))) {\n                return selector.getAttribute('content');\n            }\n            return null;\n        }\n    }]);\n    return Connector;\n}();\n\n/**\n * This class represents a basic channel.\n */\nvar Channel = function () {\n  function Channel() {\n    classCallCheck(this, Channel);\n  }\n\n  createClass(Channel, [{\n    key: 'listenForWhisper',\n\n    /**\n     * Listen for a whisper event on the channel instance.\n     */\n    value: function listenForWhisper(event, callback) {\n      return this.listen('.client-' + event, callback);\n    }\n    /**\n     * Listen for an event on the channel instance.\n     */\n\n  }, {\n    key: 'notification',\n    value: function notification(callback) {\n      return this.listen('.Illuminate\\\\Notifications\\\\Events\\\\BroadcastNotificationCreated', callback);\n    }\n  }]);\n  return Channel;\n}();\n\n/**\n * Event name formatter\n */\nvar EventFormatter = function () {\n    /**\n     * Create a new class instance.\n     */\n    function EventFormatter(namespace) {\n        classCallCheck(this, EventFormatter);\n\n        this.setNamespace(namespace);\n    }\n    /**\n     * Format the given event name.\n     */\n\n\n    createClass(EventFormatter, [{\n        key: 'format',\n        value: function format(event) {\n            if (event.charAt(0) === '.' || event.charAt(0) === '\\\\') {\n                return event.substr(1);\n            } else if (this.namespace) {\n                event = this.namespace + '.' + event;\n            }\n            return event.replace(/\\./g, '\\\\');\n        }\n        /**\n         * Set the event namespace.\n         */\n\n    }, {\n        key: 'setNamespace',\n        value: function setNamespace(value) {\n            this.namespace = value;\n        }\n    }]);\n    return EventFormatter;\n}();\n\n/**\n * This class represents a Pusher channel.\n */\nvar PusherChannel = function (_Channel) {\n    inherits(PusherChannel, _Channel);\n\n    /**\n     * Create a new class instance.\n     */\n    function PusherChannel(pusher, name, options) {\n        classCallCheck(this, PusherChannel);\n\n        var _this = possibleConstructorReturn(this, (PusherChannel.__proto__ || Object.getPrototypeOf(PusherChannel)).call(this));\n\n        _this.name = name;\n        _this.pusher = pusher;\n        _this.options = options;\n        _this.eventFormatter = new EventFormatter(_this.options.namespace);\n        _this.subscribe();\n        return _this;\n    }\n    /**\n     * Subscribe to a Pusher channel.\n     */\n\n\n    createClass(PusherChannel, [{\n        key: 'subscribe',\n        value: function subscribe() {\n            this.subscription = this.pusher.subscribe(this.name);\n        }\n        /**\n         * Unsubscribe from a Pusher channel.\n         */\n\n    }, {\n        key: 'unsubscribe',\n        value: function unsubscribe() {\n            this.pusher.unsubscribe(this.name);\n        }\n        /**\n         * Listen for an event on the channel instance.\n         */\n\n    }, {\n        key: 'listen',\n        value: function listen(event, callback) {\n            this.on(this.eventFormatter.format(event), callback);\n            return this;\n        }\n        /**\n         * Stop listening for an event on the channel instance.\n         */\n\n    }, {\n        key: 'stopListening',\n        value: function stopListening(event) {\n            this.subscription.unbind(this.eventFormatter.format(event));\n            return this;\n        }\n        /**\n         * Bind a channel to an event.\n         */\n\n    }, {\n        key: 'on',\n        value: function on(event, callback) {\n            this.subscription.bind(event, callback);\n            return this;\n        }\n    }]);\n    return PusherChannel;\n}(Channel);\n\n/**\n * This class represents a Pusher private channel.\n */\nvar PusherPrivateChannel = function (_PusherChannel) {\n    inherits(PusherPrivateChannel, _PusherChannel);\n\n    function PusherPrivateChannel() {\n        classCallCheck(this, PusherPrivateChannel);\n        return possibleConstructorReturn(this, (PusherPrivateChannel.__proto__ || Object.getPrototypeOf(PusherPrivateChannel)).apply(this, arguments));\n    }\n\n    createClass(PusherPrivateChannel, [{\n        key: 'whisper',\n\n        /**\n         * Trigger client event on the channel.\n         */\n        value: function whisper(eventName, data) {\n            this.pusher.channels.channels[this.name].trigger('client-' + eventName, data);\n            return this;\n        }\n    }]);\n    return PusherPrivateChannel;\n}(PusherChannel);\n\n/**\n * This class represents a Pusher presence channel.\n */\nvar PusherPresenceChannel = function (_PusherChannel) {\n    inherits(PusherPresenceChannel, _PusherChannel);\n\n    function PusherPresenceChannel() {\n        classCallCheck(this, PusherPresenceChannel);\n        return possibleConstructorReturn(this, (PusherPresenceChannel.__proto__ || Object.getPrototypeOf(PusherPresenceChannel)).apply(this, arguments));\n    }\n\n    createClass(PusherPresenceChannel, [{\n        key: 'here',\n\n        /**\n         * Register a callback to be called anytime the member list changes.\n         */\n        value: function here(callback) {\n            this.on('pusher:subscription_succeeded', function (data) {\n                callback(Object.keys(data.members).map(function (k) {\n                    return data.members[k];\n                }));\n            });\n            return this;\n        }\n        /**\n         * Listen for someone joining the channel.\n         */\n\n    }, {\n        key: 'joining',\n        value: function joining(callback) {\n            this.on('pusher:member_added', function (member) {\n                callback(member.info);\n            });\n            return this;\n        }\n        /**\n         * Listen for someone leaving the channel.\n         */\n\n    }, {\n        key: 'leaving',\n        value: function leaving(callback) {\n            this.on('pusher:member_removed', function (member) {\n                callback(member.info);\n            });\n            return this;\n        }\n        /**\n         * Trigger client event on the channel.\n         */\n\n    }, {\n        key: 'whisper',\n        value: function whisper(eventName, data) {\n            this.pusher.channels.channels[this.name].trigger('client-' + eventName, data);\n            return this;\n        }\n    }]);\n    return PusherPresenceChannel;\n}(PusherChannel);\n\n/**\n * This class represents a Socket.io channel.\n */\nvar SocketIoChannel = function (_Channel) {\n    inherits(SocketIoChannel, _Channel);\n\n    /**\n     * Create a new class instance.\n     */\n    function SocketIoChannel(socket, name, options) {\n        classCallCheck(this, SocketIoChannel);\n\n        /**\n         * The event callbacks applied to the channel.\n         */\n        var _this = possibleConstructorReturn(this, (SocketIoChannel.__proto__ || Object.getPrototypeOf(SocketIoChannel)).call(this));\n\n        _this.events = {};\n        _this.name = name;\n        _this.socket = socket;\n        _this.options = options;\n        _this.eventFormatter = new EventFormatter(_this.options.namespace);\n        _this.subscribe();\n        _this.configureReconnector();\n        return _this;\n    }\n    /**\n     * Subscribe to a Socket.io channel.\n     */\n\n\n    createClass(SocketIoChannel, [{\n        key: 'subscribe',\n        value: function subscribe() {\n            this.socket.emit('subscribe', {\n                channel: this.name,\n                auth: this.options.auth || {}\n            });\n        }\n        /**\n         * Unsubscribe from channel and ubind event callbacks.\n         */\n\n    }, {\n        key: 'unsubscribe',\n        value: function unsubscribe() {\n            this.unbind();\n            this.socket.emit('unsubscribe', {\n                channel: this.name,\n                auth: this.options.auth || {}\n            });\n        }\n        /**\n         * Listen for an event on the channel instance.\n         */\n\n    }, {\n        key: 'listen',\n        value: function listen(event, callback) {\n            this.on(this.eventFormatter.format(event), callback);\n            return this;\n        }\n        /**\n         * Stop listening for an event on the channel instance.\n         */\n\n    }, {\n        key: 'stopListening',\n        value: function stopListening(event) {\n            var name = this.eventFormatter.format(event);\n            this.socket.removeListener(name);\n            delete this.events[name];\n            return this;\n        }\n        /**\n         * Bind the channel's socket to an event and store the callback.\n         */\n\n    }, {\n        key: 'on',\n        value: function on(event, callback) {\n            var _this2 = this;\n\n            var listener = function listener(channel, data) {\n                if (_this2.name == channel) {\n                    callback(data);\n                }\n            };\n            this.socket.on(event, listener);\n            this.bind(event, listener);\n        }\n        /**\n         * Attach a 'reconnect' listener and bind the event.\n         */\n\n    }, {\n        key: 'configureReconnector',\n        value: function configureReconnector() {\n            var _this3 = this;\n\n            var listener = function listener() {\n                _this3.subscribe();\n            };\n            this.socket.on('reconnect', listener);\n            this.bind('reconnect', listener);\n        }\n        /**\n         * Bind the channel's socket to an event and store the callback.\n         */\n\n    }, {\n        key: 'bind',\n        value: function bind(event, callback) {\n            this.events[event] = this.events[event] || [];\n            this.events[event].push(callback);\n        }\n        /**\n         * Unbind the channel's socket from all stored event callbacks.\n         */\n\n    }, {\n        key: 'unbind',\n        value: function unbind() {\n            var _this4 = this;\n\n            Object.keys(this.events).forEach(function (event) {\n                _this4.events[event].forEach(function (callback) {\n                    _this4.socket.removeListener(event, callback);\n                });\n                delete _this4.events[event];\n            });\n        }\n    }]);\n    return SocketIoChannel;\n}(Channel);\n\n/**\n * This class represents a Socket.io presence channel.\n */\nvar SocketIoPrivateChannel = function (_SocketIoChannel) {\n    inherits(SocketIoPrivateChannel, _SocketIoChannel);\n\n    function SocketIoPrivateChannel() {\n        classCallCheck(this, SocketIoPrivateChannel);\n        return possibleConstructorReturn(this, (SocketIoPrivateChannel.__proto__ || Object.getPrototypeOf(SocketIoPrivateChannel)).apply(this, arguments));\n    }\n\n    createClass(SocketIoPrivateChannel, [{\n        key: 'whisper',\n\n        /**\n         * Trigger client event on the channel.\n         */\n        value: function whisper(eventName, data) {\n            this.socket.emit('client event', {\n                channel: this.name,\n                event: 'client-' + eventName,\n                data: data\n            });\n            return this;\n        }\n    }]);\n    return SocketIoPrivateChannel;\n}(SocketIoChannel);\n\n/**\n * This class represents a Socket.io presence channel.\n */\nvar SocketIoPresenceChannel = function (_SocketIoPrivateChann) {\n    inherits(SocketIoPresenceChannel, _SocketIoPrivateChann);\n\n    function SocketIoPresenceChannel() {\n        classCallCheck(this, SocketIoPresenceChannel);\n        return possibleConstructorReturn(this, (SocketIoPresenceChannel.__proto__ || Object.getPrototypeOf(SocketIoPresenceChannel)).apply(this, arguments));\n    }\n\n    createClass(SocketIoPresenceChannel, [{\n        key: 'here',\n\n        /**\n         * Register a callback to be called anytime the member list changes.\n         */\n        value: function here(callback) {\n            this.on('presence:subscribed', function (members) {\n                callback(members.map(function (m) {\n                    return m.user_info;\n                }));\n            });\n            return this;\n        }\n        /**\n         * Listen for someone joining the channel.\n         */\n\n    }, {\n        key: 'joining',\n        value: function joining(callback) {\n            this.on('presence:joining', function (member) {\n                return callback(member.user_info);\n            });\n            return this;\n        }\n        /**\n         * Listen for someone leaving the channel.\n         */\n\n    }, {\n        key: 'leaving',\n        value: function leaving(callback) {\n            this.on('presence:leaving', function (member) {\n                return callback(member.user_info);\n            });\n            return this;\n        }\n    }]);\n    return SocketIoPresenceChannel;\n}(SocketIoPrivateChannel);\n\n/**\n * This class represents a null channel.\n */\nvar NullChannel = function (_Channel) {\n  inherits(NullChannel, _Channel);\n\n  function NullChannel() {\n    classCallCheck(this, NullChannel);\n    return possibleConstructorReturn(this, (NullChannel.__proto__ || Object.getPrototypeOf(NullChannel)).apply(this, arguments));\n  }\n\n  createClass(NullChannel, [{\n    key: 'subscribe',\n\n    /**\n     * Subscribe to a channel.\n     */\n    value: function subscribe() {}\n    //\n\n    /**\n     * Unsubscribe from a channel.\n     */\n\n  }, {\n    key: 'unsubscribe',\n    value: function unsubscribe() {}\n    //\n\n    /**\n     * Listen for an event on the channel instance.\n     */\n\n  }, {\n    key: 'listen',\n    value: function listen(event, callback) {\n      return this;\n    }\n    /**\n     * Stop listening for an event on the channel instance.\n     */\n\n  }, {\n    key: 'stopListening',\n    value: function stopListening(event) {\n      return this;\n    }\n    /**\n     * Bind a channel to an event.\n     */\n\n  }, {\n    key: 'on',\n    value: function on(event, callback) {\n      return this;\n    }\n  }]);\n  return NullChannel;\n}(Channel);\n\n/**\n * This class represents a null private channel.\n */\nvar NullPrivateChannel = function (_NullChannel) {\n  inherits(NullPrivateChannel, _NullChannel);\n\n  function NullPrivateChannel() {\n    classCallCheck(this, NullPrivateChannel);\n    return possibleConstructorReturn(this, (NullPrivateChannel.__proto__ || Object.getPrototypeOf(NullPrivateChannel)).apply(this, arguments));\n  }\n\n  createClass(NullPrivateChannel, [{\n    key: 'whisper',\n\n    /**\n     * Trigger client event on the channel.\n     */\n    value: function whisper(eventName, data) {\n      return this;\n    }\n  }]);\n  return NullPrivateChannel;\n}(NullChannel);\n\n/**\n * This class represents a null presence channel.\n */\nvar NullPresenceChannel = function (_NullChannel) {\n  inherits(NullPresenceChannel, _NullChannel);\n\n  function NullPresenceChannel() {\n    classCallCheck(this, NullPresenceChannel);\n    return possibleConstructorReturn(this, (NullPresenceChannel.__proto__ || Object.getPrototypeOf(NullPresenceChannel)).apply(this, arguments));\n  }\n\n  createClass(NullPresenceChannel, [{\n    key: 'here',\n\n    /**\n     * Register a callback to be called anytime the member list changes.\n     */\n    value: function here(callback) {\n      return this;\n    }\n    /**\n     * Listen for someone joining the channel.\n     */\n\n  }, {\n    key: 'joining',\n    value: function joining(callback) {\n      return this;\n    }\n    /**\n     * Listen for someone leaving the channel.\n     */\n\n  }, {\n    key: 'leaving',\n    value: function leaving(callback) {\n      return this;\n    }\n    /**\n     * Trigger client event on the channel.\n     */\n\n  }, {\n    key: 'whisper',\n    value: function whisper(eventName, data) {\n      return this;\n    }\n  }]);\n  return NullPresenceChannel;\n}(NullChannel);\n\n/**\n * This class creates a connector to Pusher.\n */\nvar PusherConnector = function (_Connector) {\n    inherits(PusherConnector, _Connector);\n\n    function PusherConnector() {\n        classCallCheck(this, PusherConnector);\n\n        /**\n         * All of the subscribed channel names.\n         */\n        var _this = possibleConstructorReturn(this, (PusherConnector.__proto__ || Object.getPrototypeOf(PusherConnector)).apply(this, arguments));\n\n        _this.channels = {};\n        return _this;\n    }\n    /**\n     * Create a fresh Pusher connection.\n     */\n\n\n    createClass(PusherConnector, [{\n        key: 'connect',\n        value: function connect() {\n            if (typeof this.options.client !== 'undefined') {\n                this.pusher = this.options.client;\n            } else {\n                this.pusher = new Pusher(this.options.key, this.options);\n            }\n        }\n        /**\n         * Listen for an event on a channel instance.\n         */\n\n    }, {\n        key: 'listen',\n        value: function listen(name, event, callback) {\n            return this.channel(name).listen(event, callback);\n        }\n        /**\n         * Get a channel instance by name.\n         */\n\n    }, {\n        key: 'channel',\n        value: function channel(name) {\n            if (!this.channels[name]) {\n                this.channels[name] = new PusherChannel(this.pusher, name, this.options);\n            }\n            return this.channels[name];\n        }\n        /**\n         * Get a private channel instance by name.\n         */\n\n    }, {\n        key: 'privateChannel',\n        value: function privateChannel(name) {\n            if (!this.channels['private-' + name]) {\n                this.channels['private-' + name] = new PusherPrivateChannel(this.pusher, 'private-' + name, this.options);\n            }\n            return this.channels['private-' + name];\n        }\n        /**\n         * Get a presence channel instance by name.\n         */\n\n    }, {\n        key: 'presenceChannel',\n        value: function presenceChannel(name) {\n            if (!this.channels['presence-' + name]) {\n                this.channels['presence-' + name] = new PusherPresenceChannel(this.pusher, 'presence-' + name, this.options);\n            }\n            return this.channels['presence-' + name];\n        }\n        /**\n         * Leave the given channel, as well as its private and presence variants.\n         */\n\n    }, {\n        key: 'leave',\n        value: function leave(name) {\n            var _this2 = this;\n\n            var channels = [name, 'private-' + name, 'presence-' + name];\n            channels.forEach(function (name, index) {\n                _this2.leaveChannel(name);\n            });\n        }\n        /**\n         * Leave the given channel.\n         */\n\n    }, {\n        key: 'leaveChannel',\n        value: function leaveChannel(name) {\n            if (this.channels[name]) {\n                this.channels[name].unsubscribe();\n                delete this.channels[name];\n            }\n        }\n        /**\n         * Get the socket ID for the connection.\n         */\n\n    }, {\n        key: 'socketId',\n        value: function socketId() {\n            return this.pusher.connection.socket_id;\n        }\n        /**\n         * Disconnect Pusher connection.\n         */\n\n    }, {\n        key: 'disconnect',\n        value: function disconnect() {\n            this.pusher.disconnect();\n        }\n    }]);\n    return PusherConnector;\n}(Connector);\n\n/**\n * This class creates a connnector to a Socket.io server.\n */\nvar SocketIoConnector = function (_Connector) {\n    inherits(SocketIoConnector, _Connector);\n\n    function SocketIoConnector() {\n        classCallCheck(this, SocketIoConnector);\n\n        /**\n         * All of the subscribed channel names.\n         */\n        var _this = possibleConstructorReturn(this, (SocketIoConnector.__proto__ || Object.getPrototypeOf(SocketIoConnector)).apply(this, arguments));\n\n        _this.channels = {};\n        return _this;\n    }\n    /**\n     * Create a fresh Socket.io connection.\n     */\n\n\n    createClass(SocketIoConnector, [{\n        key: 'connect',\n        value: function connect() {\n            var io = this.getSocketIO();\n            this.socket = io(this.options.host, this.options);\n            return this.socket;\n        }\n        /**\n         * Get socket.io module from global scope or options.\n         */\n\n    }, {\n        key: 'getSocketIO',\n        value: function getSocketIO() {\n            if (typeof io !== 'undefined') {\n                return io;\n            }\n            if (typeof this.options.client !== 'undefined') {\n                return this.options.client;\n            }\n            throw new Error('Socket.io client not found. Should be globally available or passed via options.client');\n        }\n        /**\n         * Listen for an event on a channel instance.\n         */\n\n    }, {\n        key: 'listen',\n        value: function listen(name, event, callback) {\n            return this.channel(name).listen(event, callback);\n        }\n        /**\n         * Get a channel instance by name.\n         */\n\n    }, {\n        key: 'channel',\n        value: function channel(name) {\n            if (!this.channels[name]) {\n                this.channels[name] = new SocketIoChannel(this.socket, name, this.options);\n            }\n            return this.channels[name];\n        }\n        /**\n         * Get a private channel instance by name.\n         */\n\n    }, {\n        key: 'privateChannel',\n        value: function privateChannel(name) {\n            if (!this.channels['private-' + name]) {\n                this.channels['private-' + name] = new SocketIoPrivateChannel(this.socket, 'private-' + name, this.options);\n            }\n            return this.channels['private-' + name];\n        }\n        /**\n         * Get a presence channel instance by name.\n         */\n\n    }, {\n        key: 'presenceChannel',\n        value: function presenceChannel(name) {\n            if (!this.channels['presence-' + name]) {\n                this.channels['presence-' + name] = new SocketIoPresenceChannel(this.socket, 'presence-' + name, this.options);\n            }\n            return this.channels['presence-' + name];\n        }\n        /**\n         * Leave the given channel, as well as its private and presence variants.\n         */\n\n    }, {\n        key: 'leave',\n        value: function leave(name) {\n            var _this2 = this;\n\n            var channels = [name, 'private-' + name, 'presence-' + name];\n            channels.forEach(function (name) {\n                _this2.leaveChannel(name);\n            });\n        }\n        /**\n         * Leave the given channel.\n         */\n\n    }, {\n        key: 'leaveChannel',\n        value: function leaveChannel(name) {\n            if (this.channels[name]) {\n                this.channels[name].unsubscribe();\n                delete this.channels[name];\n            }\n        }\n        /**\n         * Get the socket ID for the connection.\n         */\n\n    }, {\n        key: 'socketId',\n        value: function socketId() {\n            return this.socket.id;\n        }\n        /**\n         * Disconnect Socketio connection.\n         */\n\n    }, {\n        key: 'disconnect',\n        value: function disconnect() {\n            this.socket.disconnect();\n        }\n    }]);\n    return SocketIoConnector;\n}(Connector);\n\n/**\n * This class creates a null connector.\n */\nvar NullConnector = function (_Connector) {\n  inherits(NullConnector, _Connector);\n\n  function NullConnector() {\n    classCallCheck(this, NullConnector);\n\n    /**\n     * All of the subscribed channel names.\n     */\n    var _this = possibleConstructorReturn(this, (NullConnector.__proto__ || Object.getPrototypeOf(NullConnector)).apply(this, arguments));\n\n    _this.channels = {};\n    return _this;\n  }\n  /**\n   * Create a fresh connection.\n   */\n\n\n  createClass(NullConnector, [{\n    key: 'connect',\n    value: function connect() {}\n    //\n\n    /**\n     * Listen for an event on a channel instance.\n     */\n\n  }, {\n    key: 'listen',\n    value: function listen(name, event, callback) {\n      return new NullChannel();\n    }\n    /**\n     * Get a channel instance by name.\n     */\n\n  }, {\n    key: 'channel',\n    value: function channel(name) {\n      return new NullChannel();\n    }\n    /**\n     * Get a private channel instance by name.\n     */\n\n  }, {\n    key: 'privateChannel',\n    value: function privateChannel(name) {\n      return new NullPrivateChannel();\n    }\n    /**\n     * Get a presence channel instance by name.\n     */\n\n  }, {\n    key: 'presenceChannel',\n    value: function presenceChannel(name) {\n      return new NullPresenceChannel();\n    }\n    /**\n     * Leave the given channel, as well as its private and presence variants.\n     */\n\n  }, {\n    key: 'leave',\n    value: function leave(name) {}\n    //\n\n    /**\n     * Leave the given channel.\n     */\n\n  }, {\n    key: 'leaveChannel',\n    value: function leaveChannel(name) {}\n    //\n\n    /**\n     * Get the socket ID for the connection.\n     */\n\n  }, {\n    key: 'socketId',\n    value: function socketId() {\n      return 'fake-socket-id';\n    }\n    /**\n     * Disconnect the connection.\n     */\n\n  }, {\n    key: 'disconnect',\n    value: function disconnect() {\n      //\n    }\n  }]);\n  return NullConnector;\n}(Connector);\n\n/**\n * This class is the primary API for interacting with broadcasting.\n */\n\nvar Echo = function () {\n    /**\n     * Create a new class instance.\n     */\n    function Echo(options) {\n        classCallCheck(this, Echo);\n\n        this.options = options;\n        this.connect();\n        this.registerInterceptors();\n    }\n    /**\n     * Get a channel instance by name.\n     */\n\n\n    createClass(Echo, [{\n        key: 'channel',\n        value: function channel(_channel) {\n            return this.connector.channel(_channel);\n        }\n        /**\n         * Create a new connection.\n         */\n\n    }, {\n        key: 'connect',\n        value: function connect() {\n            if (this.options.broadcaster == 'pusher') {\n                this.connector = new PusherConnector(this.options);\n            } else if (this.options.broadcaster == 'socket.io') {\n                this.connector = new SocketIoConnector(this.options);\n            } else if (this.options.broadcaster == 'null') {\n                this.connector = new NullConnector(this.options);\n            }\n        }\n        /**\n         * Disconnect from the Echo server.\n         */\n\n    }, {\n        key: 'disconnect',\n        value: function disconnect() {\n            this.connector.disconnect();\n        }\n        /**\n         * Get a presence channel instance by name.\n         */\n\n    }, {\n        key: 'join',\n        value: function join(channel) {\n            return this.connector.presenceChannel(channel);\n        }\n        /**\n         * Leave the given channel, as well as its private and presence variants.\n         */\n\n    }, {\n        key: 'leave',\n        value: function leave(channel) {\n            this.connector.leave(channel);\n        }\n        /**\n         * Leave the given channel.\n         */\n\n    }, {\n        key: 'leaveChannel',\n        value: function leaveChannel(channel) {\n            this.connector.leaveChannel(channel);\n        }\n        /**\n         * Listen for an event on a channel instance.\n         */\n\n    }, {\n        key: 'listen',\n        value: function listen(channel, event, callback) {\n            return this.connector.listen(channel, event, callback);\n        }\n        /**\n         * Get a private channel instance by name.\n         */\n\n    }, {\n        key: 'private',\n        value: function _private(channel) {\n            return this.connector.privateChannel(channel);\n        }\n        /**\n         * Get the Socket ID for the connection.\n         */\n\n    }, {\n        key: 'socketId',\n        value: function socketId() {\n            return this.connector.socketId();\n        }\n        /**\n         * Register 3rd party request interceptiors. These are used to automatically\n         * send a connections socket id to a Laravel app with a X-Socket-Id header.\n         */\n\n    }, {\n        key: 'registerInterceptors',\n        value: function registerInterceptors() {\n            if (typeof Vue === 'function' && Vue.http) {\n                this.registerVueRequestInterceptor();\n            }\n            if (typeof axios === 'function') {\n                this.registerAxiosRequestInterceptor();\n            }\n            if (typeof jQuery === 'function') {\n                this.registerjQueryAjaxSetup();\n            }\n        }\n        /**\n         * Register a Vue HTTP interceptor to add the X-Socket-ID header.\n         */\n\n    }, {\n        key: 'registerVueRequestInterceptor',\n        value: function registerVueRequestInterceptor() {\n            var _this = this;\n\n            Vue.http.interceptors.push(function (request, next) {\n                if (_this.socketId()) {\n                    request.headers.set('X-Socket-ID', _this.socketId());\n                }\n                next();\n            });\n        }\n        /**\n         * Register an Axios HTTP interceptor to add the X-Socket-ID header.\n         */\n\n    }, {\n        key: 'registerAxiosRequestInterceptor',\n        value: function registerAxiosRequestInterceptor() {\n            var _this2 = this;\n\n            axios.interceptors.request.use(function (config) {\n                if (_this2.socketId()) {\n                    config.headers['X-Socket-Id'] = _this2.socketId();\n                }\n                return config;\n            });\n        }\n        /**\n         * Register jQuery AjaxSetup to add the X-Socket-ID header.\n         */\n\n    }, {\n        key: 'registerjQueryAjaxSetup',\n        value: function registerjQueryAjaxSetup() {\n            var _this3 = this;\n\n            if (typeof jQuery.ajax != 'undefined') {\n                jQuery.ajaxSetup({\n                    beforeSend: function beforeSend(xhr) {\n                        if (_this3.socketId()) {\n                            xhr.setRequestHeader('X-Socket-Id', _this3.socketId());\n                        }\n                    }\n                });\n            }\n        }\n    }]);\n    return Echo;\n}();\n\nmodule.exports = Echo;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/laravel-echo/dist/echo.common.js\n// module id = 2\n// module chunks = 0"],"sourceRoot":""}